#+TITLE: Tom's Emacs Init File
 
So this is fun. I can now use literate programming to configure my OS..err text editor.

Pleas note that a *HUGE* chunk of this file was shamelessly stolen from the snippets in
https://writequit.org/eos. I am standing on the shoulders of giants. 
 
* Bootstrap
  Let's get started by adding my custom folders to my load path:
** Debugging

#+BEGIN_SRC emacs-lisp 
  (setq debug-on-error nil)
#+END_SRC

** Package Management
 
Here's where I install local packages:
 
#+BEGIN_SRC emacs-lisp 
  (let ((default-directory  "~/.emacs.d/customizations/packages/"))
    (normal-top-level-add-subdirs-to-load-path))
 
  (add-to-list 'load-path "~/.emacs.d/customizations/lisp/")
#+END_SRC

I guess I'll add the melpa stuff even though I don't think I can use it:
 
#+BEGIN_SRC emacs-lisp
  (require 'package) ;; You might already have this line
  (add-to-list 'package-archives
               '("melpa" . "http://stable.melpa.org/packages/")
               '("org" . "https://orgmode.org/elpa/"))
  (package-initialize) ;; You might already have this line
#+END_SRC

And finally, =use-package=:

#+BEGIN_SRC emacs-lisp
  ;; This is only needed once, near the top of the file
  (eval-when-compile
    (require 'use-package))
#+END_SRC

** Global Properties
 
Open everything in the preferred browser:
 
#+BEGIN_SRC emacs-lisp
  (cond
   ((string-equal system-type "windows-nt") ; Microsoft Windows
    (progn
      (setq browse-url-browser-function 'browse-url-generic
            browse-url-generic-program "C:/Program Files (x86)/Google/Chrome/Application/chrome.exe")))
   ((string-equal system-type "gnu/linux") ; linux
    (progn
      (setq browse-url-browser-function 'browse-url-generic
            browse-url-generic-program "/usr/bin/chromium")))
   )
#+END_SRC

Now on to Org

** System Path

Since I usually don't start Emacs from the command line I need to
append some of my custom apps to the Emacs path.

#+BEGIN_SRC emacs-lisp
  (setq chocolatey-root "c:/ProgramData/chocolatey")
  (setq chocolatey-lib
        (concat chocolatey-root "/" "lib"))
  (setq chocolatey-bin
        (concat chocolatey-root "/" "bin"))
  ;; I'm 98% sure this doesn't actually do anything useful
  ;; (setenv "PATH"
  ;; 	(concat
  ;; 	 "C:/Program Files/Git/bin" ";"
  ;; 	 "C:/Python27" ";"
  ;; 	 "c:/ProgramData/chocolatey/bin" ";"
  ;; 	 (getenv "PATH")
  ;; 	 )
  ;; 	)
  (setq exec-path (append '("C:/Python27"
                            "c:/ProgramData/chocolatey/bin")
                          exec-path))
#+END_SRC
** Character Encoding
   UTF-8 is the only thing that makes sense for me.
#+BEGIN_SRC emacs-lisp
  ; Shamelessly stolen from https://writequit.org/eos/eos-core.html
  (set-charset-priority 'unicode)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  (cond
   ((string-equal system-type "windows-nt")
    (progn
      (setq default-process-coding-system '(utf-8-dos . utf-8-dos))))
   ((string-equal system-type "gnu/linux")
    (progn
      (setq default-process-coding-system '(utf-8-unix . utf-8-unix)))))
#+END_SRC
** Startup Stuff
   I don't want to see the startup screen. Just dump me into a scratch buffer.
   #+BEGIN_SRC emacs-lisp
     (setq inhibit-startup-screen t)
   #+END_SRC
* Eye Candy
** Themes
*** Poet Theme
#+BEGIN_SRC emacs-lisp
  ;; This has to be installed manually
  (require 'poet-theme)
  (load-theme 'poet 1)
#+END_SRC
*** Dracula
    #+BEGIN_SRC emacs-lisp
      ;; (use-package dracula-theme
      ;;   :ensure t)
    #+END_SRC

** Centering Prose
*** Olivetti
    This is a *sweet* minor mode that makes prose pages look much nicer. 
    #+BEGIN_SRC emacs-lisp
      (use-package olivetti
        :ensure t
        :init
        :config
        (add-hook 'org-mode-hook
                  (lambda ()
                    (olivetti-mode 1))))
      (custom-set-variables
       '(olivetti-body-width 100))
    #+END_SRC

    Since the screen width for prose is now 100 I'm going to bump up paragraph width too:

#+BEGIN_SRC emacs-lisp
  (setq-default fill-column 90)
#+END_SRC

    Since Olivetti breaks up long lines =C-k= (which maps to =kill-line=) doesn't actually kill the
    entire line. Thanks to Xah yet again I have a solution:

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-9") 'kill-whole-line)
#+END_SRC

** Font
*** Font Choices
    Big fonts + Windows makes Emacs something somthing (slow down terribly). 
#+BEGIN_SRC emacs-lisp
  (cond
   ((string-equal system-type "windows-nt")
    (progn
      (setq inhibit-compacting-font-caches 1))))
#+END_SRC

 #+BEGIN_SRC emacs-lisp
   (set-face-attribute 'default nil :family "Ubuntu Mono" :height 140)
   (set-face-attribute 'fixed-pitch nil :family "Ubuntu Mono" :height 140)
   (set-face-attribute 'variable-pitch nil :family "Ubuntu Light" :height 140)
 #+END_SRC

*** Viewing monospaced and non-monospaced fonts in the same document
    Emacs has a great feature that allows you to view non-code text using a proportional font (like
    Helvetica) and code text using a non-proportional font (like Courier). You just have to run this
    below:

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook
            (lambda ()
              (variable-pitch-mode 1)))
#+END_SRC

  For whatever reason I can never the name of the =variable-pitch-mode= function so here's
  my own alias:

#+BEGIN_SRC emacs-lisp
  (defun tp/font/toggle-variable-pitch-mode ()
    (interactive)
    (variable-pitch-mode nil))
#+END_SRC

** Emojify mode
Let's make it globally accessible.
#+BEGIN_SRC emacs-lisp
  (use-package emojify
    :ensure t
    :init
    (add-hook 'after-init-hook #'global-emojify-mode))
#+END_SRC
** Powerline
#+BEGIN_SRC emacs-lisp
  (use-package powerline
    :ensure t
    :config
    (powerline-default-theme))
#+END_SRC
** Hide DOS EOL Char's (^M)
   This is thanks to https://stackoverflow.com/a/750933/1380901
 #+BEGIN_SRC emacs-lisp
   (defun tp/remove-dos-eol ()
     "Do not show ^M in files containing mixed UNIX and DOS line endings."
     (interactive)
     (setq buffer-display-table (make-display-table))
     (aset buffer-display-table ?\^M []))
 #+END_SRC
** Toolbars And Menubars And Such
   All of this is shamelessly stolen from https://writequit.org/eos/eos-core.html:
   #+BEGIN_SRC emacs-lisp
     (when (functionp 'menu-bar-mode)
       (menu-bar-mode -1))
     (when (functionp 'set-scroll-bar-mode)
       (set-scroll-bar-mode 'nil))
     (when (functionp 'mouse-wheel-mode)
       (mouse-wheel-mode -1))
     (when (functionp 'tooltip-mode)
       (tooltip-mode -1))
     (when (functionp 'tool-bar-mode)
       (tool-bar-mode -1))
     (when (functionp 'blink-cursor-mode)
       (blink-cursor-mode -1))
   #+END_SRC
** Line Numbers
   Of course you need this!
   #+BEGIN_SRC emacs-lisp
     (global-linum-mode t)
   #+END_SRC
** Dumb Stuff
*** Nyan Cat Stuff
#+BEGIN_SRC emacs-lisp
  (use-package zone-nyan
    :ensure t)
  (use-package nyan-mode
    :ensure t
    :init
    (add-hook 'after-init-hook #'nyan-mode)
    :config
    (nyan-start-animation))
#+END_SRC

* YAS
** Bootstrap
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
    (yas-global-mode 1))
#+END_SRC
* ORG!!!!!!!!!!!!!!!
** Global Varables
#+BEGIN_SRC emacs-lisp 
  (cond
   ((string-equal system-type "windows-nt")
    (progn
      (setq org-directory "~/org/")))
   ((string-equal system-type "gnu/linux")
    (progn
      (setq org-directory "~/gtd/org/"))))

  (setq org-log-done 'time)
#+END_SRC
   
Here are global properties that are available to each file. For more
information on the "*_ALL" properties check this out:
 
- https://www.gnu.org/software/emacs/manual/html_node/org/Property-syntax.html
 
#+BEGIN_SRC emacs-lisp
  ;; Effort and global properties
  (setq org-global-properties
	'(
	  ("POM_Estimate_ALL". "n/a 1 2 3 4 5 6 7 8 9 10")
	  ("PRIORITIES" . "AAA AA A B C")))
#+END_SRC

** Keymaps
#+BEGIN_SRC emacs-lisp 
  (define-key global-map "\C-cl" 'org-store-link)
  (define-key global-map "\C-ca" 'org-agenda)
  (global-set-key (kbd "<f4>") 'set-org-agenda-files)
  (global-set-key (kbd "<f5>") 'org-toggle-inline-images)
  (define-key global-map "\C-cc" 'org-capture)
  (global-set-key (kbd "C-c h") 'open-org-html-file-in-browser)
  (global-set-key (kbd "<f6>") (lambda() (interactive)(org-publish-current-file)))
#+END_SRC

I know this doesn't work but I think I'm close:
 
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c C-x C-p") 'org-pomodoro)
#+END_SRC
** Eye Candy
*** No extra lines between headers
Org sometimes adds an extra line between headers, which drives me
nuts. This fixes that:

#+BEGIN_SRC emacs-lisp
  (setq org-blank-before-new-entry
	'((heading . nil) (plain-list-item . nil)))
#+END_SRC

** Spell Checking
*** Configure Spell Checker Name
#+BEGIN_SRC emacs-lisp
  (cond
   ((string-equal system-type "windows-nt")
    (progn
      (setq ispell-program-name 
            (concat chocolatey-lib "/" "hunspell.portable/tools/bin/hunspell"))))
   )
#+END_SRC
*** Use flyspell in Org
#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :ensure t
    :init
    (add-hook 'org-mode-hook
              (lambda () (flyspell-mode 1))))
#+END_SRC
** Navigation
*** Open links in the same window, from here:
 
- http://stackoverflow.com/a/13075322
 
#+BEGIN_SRC emacs-lisp
  (setq org-link-frame-setup (quote ((vm . vm-visit-folder-other-frame)
                                     (vm-imap . vm-visit-imap-folder-other-frame)
                                     (gnus . org-gnus-no-new-news)
                                     (file . find-file)
                                     (wl . wl-other-frame))))
#+END_SRC
** Org-agenda
*** Specify the files that can be used in an agenda
 
#+BEGIN_SRC emacs-lisp
  (defun set-org-agenda-files ()
    (interactive)
    (message "Saving all org buffers to keep agenda files list clean")
    (org-save-all-org-buffers)
    (setq org-agenda-files (list org-directory))
    (message "Done setting org agenda files."))

  (set-org-agenda-files)
#+END_SRC
 
*** Custom Views
 
Here's my custom agenda view that uses "column view". 
 
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-overriding-columns-format
        "%TODO %4PRIORITY(Pri.) %50ITEM(Task) %11Effort(Est. Effort){:} %10POM_Pomodori(Poms) %TAGS")
  (setq org-agenda-view-columns-initially t)
  (setq org-agenda-custom-commands
        '(("." "Simple agenda view"
           ((tags "+today"
                       ((org-agenda-span 'day)
                        ))
            (agenda "")))))
#+END_SRC

This only shows today's tasks in the agenda view by default:
 
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-span 1)
#+END_SRC
 
Finally, this appears to be necessary to get the =clocksum= functions
to run properly on startup:
 
#+BEGIN_SRC emacs-lisp
(org-clock-sum)
#+END_SRC
 
*** Helpers 
**** Removing the today tag from a todo 
 
This function clears out the "today" tag from the tasks in my custom
view above.
 
Note: This function is *very* brittle and will need to change if you
make any changes to your org-agenda view.
 
#+BEGIN_SRC emacs-lisp
  (fset 'tp/org-remove-today-tag
        (lambda (&optional arg)
          "Keyboard macro."
          (interactive "p")
          (kmacro-exec-ring-item '([6 6 6 6 6 6 101 116 return 14 1] 0 "%d") arg))) 
#+END_SRC

**** Removing The Recorded Pomodoro Count
 
#+BEGIN_SRC emacs-lisp
  (fset 'tp/org-remove-pom-count
        (lambda (&optional arg)
          "Removes the pomodoro count from a task while viewing the agenda in column mode."
          (interactive "p")
          (kmacro-exec-ring-item
           (quote ([6 6 6 6 101 1 11 return 14 1] 0 "%d")) arg)))
#+END_SRC
** Org-Clock
   Set your default parameters for clock reports when they are viewed i the agenda view:

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-clockreport-parameter-plist
        '(:scope agenda-with-archives :formula % :maxlevel 10 :tags t :fileskip0 t :compact t :narrow 60 :score 0))
#+END_SRC

   If I'm idle for more than X minutes then ask me what to do with the clock time:
   
   #+BEGIN_SRC emacs-lisp
     (setq org-clock-idle-time 15)
   #+END_SRC


** Org-capture
*** Properties
#+BEGIN_SRC emacs-lisp
  (setq org-default-notes-file (concat org-directory "/notes.org"))
#+END_SRC
*** Templates
#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(
          ("t" "Todo" entry (file+headline (lambda () (concat org-directory "inbox.org")) "In-Process") "* TODO %? %^g")
          ("w" "Work Log" entry (file+headline (lambda () (concat org-directory "/WorkLogs.org")) "On-Deck") "** %(create-org-link 1) %?")
          ("d" "Daily Review" entry (file+headline (lambda () (concat org-directory "/Personal_Reviews.org")) "Daily") "** %(create-org-link 1 \"Daily Review\") %?")
          ("r" "Research Note" entry (file+headline (lambda () (concat org-directory "/ResearchNotes.org")) "In-Process") "** %(create-org-link nil) %?")
          ("l" "Lessons Learned" entry (file+headline (lambda () (concat org-directory "/LessonsLearned.org")) "Drafts") "** %(create-org-link nil) %?")
          ("m" "Meeting Minute" entry (file+headline (lambda () (concat org-directory "/MeetingMinutes.org")) "In-Process") "** %(create-org-link 1) %?")
          ))
#+END_SRC

** To-do Lists
*** Workflow States
 
#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
        '((sequence "TODO(t)" "WAIT(w@/!)" "|" "DONE(d!)" "CANCELED(c@)")))
#+END_SRC
*** Misc Props
Have org measure todo completion percentage recursively. =nil= means
that you want it to look recursively.
 
#+BEGIN_SRC emacs-lisp
  (setq org-hierarchical-todo-statistics nil)
#+END_SRC
 
** Functions
*** Calculating Dates
#+BEGIN_SRC emacs-lisp
  (defvar org-link-date-stamp-format "%y%m%d"
    "Format of date stamps to use in Org links")
 
  (defun add-date-stamp-to-file-name (org-link)
    "Add a date stamp to the file name portion of an org link"
    (replace-regexp-in-string ":" 
                              (concat ":" 
                                      (format-time-string org-link-date-stamp-format (current-time))
                                      "-") org-link))
 
  (defun add-date-stamp-to-link-title (org-link)
    "Add a date stamp to the title portion of an org link"
    (replace-regexp-in-string "\\]\\[" 
                              (concat "][" 
                                      (format-time-string org-link-date-stamp-format (current-time)) 
                                      " - ") org-link))
#+END_SRC
*** Misc
 
This is just a minor utility function.
 
#+BEGIN_SRC emacs-lisp
  (defun escape-file-titles (title)
    "Take an arbitrary string and replace all of the bad chars with
    underscores"
    (replace-regexp-in-string " " "_" title))
#+END_SRC
 
Here's a much better version of my create-org-link function courtesy
of -> http://emacs.stackexchange.com/a/12166/8228
 
#+BEGIN_SRC emacs-lisp
  (defun create-org-link (addDate? &optional title)
    "Takes a human-readable title for a link and returns a
     nicely-formatted file link."
    (interactive)
    (unless title
      (setq title
            (read-string "Please enter a title: ")))
    (let ((plain-file-link
           (format "[[file:%s.org][%s]]" (escape-file-titles title) title)))
      (let ((formatted-file-link
             (if addDate?
                 (add-date-stamp-to-file-name (add-date-stamp-to-link-title plain-file-link))
               plain-file-link)))
        (if (called-interactively-p)
            (insert formatted-file-link)
          formatted-file-link))))
#+END_SRC

*** Browser-related
#+BEGIN_SRC emacs-lisp
  (defun org-file-name-convert-to-html (org-file-name)
    "Convert an org file name into its HTML eqlivalent"
    (replace-regexp-in-string 
     "\\(.*\\)\\/org\\/\\(.*\\)\.org$" 
     "\\1/org/\\2.html" org-file-name))
 
  (defun open-org-html-file-in-browser ()
    "Open the current html version of the current org file in a web
    browser."
    (interactive)
    (browse-url-of-file (org-file-name-convert-to-html (buffer-file-name))))
#+END_SRC
** Auto Insertion
 
When creating new org files I like to insert a nicely-formatted title
at the top that's based on the file name. The code below does things
like replace underscores with spaces so that a file name like
"This_Is_Cool.org" will automatically have a title of "This Is Cool".
 
#+BEGIN_SRC emacs-lisp
  (defun format-page-title-from-buffer-name ()
    "Takes a buffer name and returns a much more friendly looking
    title.
 
    Note: This function assumes that the create-org-link function
    replaces spaces with underscores"
    (interactive)
    (replace-regexp-in-string "\.org" ""
                              (replace-regexp-in-string "_" " "
                                                        (replace-regexp-in-string "\w-\w" " - " (buffer-name))))
    )
 
  (defun org-file-header ()
    "Generate a header for an org mode file"
    (interactive)
    (let ((out (format "#+TITLE: %s
 
  "
                       (format-page-title-from-buffer-name))))
      out))
 
  (defun org-file-insert ()
    "Insert a header containing HTML boilerplate and a title and
     whatever else you want."
    (interactive)
    (insert (org-file-header)))
 
  (add-hook 'find-file-hook 'auto-insert)
  (define-auto-insert ".*\.org$" 'org-file-insert)
 
                                          ; Don't ask for confirmation if auto-insert is called non-interactively.
  (setq auto-insert-query nil)
#+END_SRC
 
** Org-publish
*** Bootstrap
 
#+BEGIN_SRC emacs-lisp
(require 'ox-publish)
#+END_SRC

#+RESULTS:
: ox-publish

*** Projects
 
Since this is an alist I don't know how to embed functions in
it. Thats's why I've replaced the org-directory var with the literal
value.
 
#+BEGIN_SRC emacs-lisp
  (setq org-publish-project-alist
        '(
          ("org-notes"               ;Used to export .org file
           :base-directory "~/org/"  ;directory holds .org files 
           :base-extension "org"     ;process .org file only    
           :publishing-directory "~/org/"    ;export destination
           :recursive t
           :publishing-function org-html-publish-to-html
           :headline-levels 4               ; Just the default for this project.
           :auto-preamble t
           :auto-sitemap t                  ; Generate sitemap.org automagically...
           :sitemap-filename "sitemap.org"  ; ... call it sitemap.org (it's the default)...
           :sitemap-title "Sitemap"         ; ... with title 'Sitemap'.
           :export-creator-info nil    ; Disable the inclusion of "Created by Org" in the postamble.
           :export-author-info nil     ; Disable the inclusion of "Author: Your Name" in the postamble.
           :auto-postamble nil         ; Disable auto postamble 
           :table-of-contents t        ; Set this to "t" if you want a table of contents, set to "nil" disables TOC.
           :section-numbers nil        ; Set this to "t" if you want headings to have numbers.
           :html-postamble "    <p class=\"postamble\">Last Updated %d.</p> " ; your personal postamble
           :style-include-default nil  ;Disable the default css style
           :html-head "<link id='pagestyle' rel='stylesheet' type='text/css' href='static/css/org.css' />\n<link id='pagestyle' rel='stylesheet' type='text/css' href='static/css/custom.css' />"
           
           ("org-static"                ;Used to publish static files
            :base-directory "~/org/static/"
            :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf"
            :publishing-directory "~/org/"
            :recursive t
            :publishing-function org-publish-attachment
            )
           ("org" :components ("org-notes" "org-static"))) ;combine "org-static" and "org-static" into one function call
          ))
#+END_SRC

*** Exporting To (Github-Flavored) Markdown
    #+BEGIN_SRC emacs-lisp
      (use-package ox-gfm
        :ensure t)
    #+END_SRC
** Yasnippet
#+BEGIN_SRC emacs-lisp
  (defun yas/org-very-safe-expand ()
    (let ((yas/fallback-behavior 'return-nil)) (yas/expand)))
 
  (add-hook 'org-mode-hook
            (lambda ()
              (make-variable-buffer-local 'yas/trigger-key)
              (setq yas/trigger-key [tab])
              (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
              (define-key yas/keymap [tab] 'yas/next-field)))
#+END_SRC

** Babel
 
Here's the languages that I can interpret. Note that there's a difference between the way that the =shell= language is loaded between older and newer versions of Emacs. This my hacky way of fixing it for now:
 
#+BEGIN_SRC emacs-lisp
  (cond
   ((string-equal system-type "windows-nt")
    (progn
      (org-babel-do-load-languages
       'org-babel-load-languages
       '((js . t)
         (emacs-lisp . t)
         (shell . t)
         (python . t)
         (dot . t)))))
   ((string-equal system-type "gnu/linux")
    (progn
      (org-babel-do-load-languages
       'org-babel-load-languages
       '((js . t)
         (emacs-lisp . t)
         (sh . t)
         (python . t)
         (dot . t))))))
#+END_SRC

I don't want to manually confirm that code written in the following
languages can be executed:
 
#+BEGIN_SRC emacs-lisp
  (defun my-org-confirm-evaluate (lang body)
    (and (not (string= lang "js"))
         (not (string= lang "dot"))
         (not (string= lang "python"))))
 
  (setq org-confirm-babel-evaluate 'my-org-confirm-evaluate)
#+END_SRC

#+RESULTS:
: my-org-confirm-evaluate

 
Here are my global =src= block headers. So far, all this does is
ensure that the publishing process never executes the code in src
block (unless it's overrided at a lower lever of course).
 
#+BEGIN_SRC emacs-lisp
  (setq org-babel-default-header-args
        (cons '(:eval . "never-export")
              (assq-delete-all :eval org-babel-default-header-args)))
#+END_SRC

#+RESULTS:

** Tags
These are the tags that I will use the most when creating new tasks.
 
#+BEGIN_SRC emacs-lisp

  (setq org-tag-alist '(
                        ("c_admin" . ?a)
                        ("c_coding" . ?c)
                        ("goal" . ?g)
                        ("c_hardware_troubleshooting" . ?h)
                        ("c_training" . ?i)
                        ("c_manual_testing" . ?m)
                        ("c_meetings" . ?e)
                        ("objective" . ?o)
                        ("c_project_planning" . ?p)
                        ("c_hr" . ?r)                      
                        ("today" . ?t)
                        ("c_system_maintenance" . ?z)
                        ))
#+END_SRC

** Org bullets
Of course you need these :smile:
 
#+BEGIN_SRC emacs-lisp 
  (use-package org-bullets
    :ensure t
    :init
    (require 'org-bullets)
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC
** Images
   This turns on inline images at startup:

   #+BEGIN_SRC emacs-lisp
     (setq org-startup-with-inline-images t)
   #+END_SRC

   ... and this scales them down when viewing them inline:

   #+BEGIN_SRC emacs-lisp
     (setq org-image-actual-width 600)
   #+END_SRC

* Magit
** Bootstrap

First, install magit:

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t)
#+END_SRC
 
I'm currently stuck in dependency hell here and the old version of
magit doesn't work so I'm just going to comment all of this out.
 
#+BEGIN_SRC emacs-lisp
  (cond
   ((string-equal system-type "windows-nt")
    (progn
  (add-to-list 'exec-path "c:/Program Files/Git/bin")    
      )))
#+END_SRC
** SSH Stuff

Pushing to an SSH repo using Windows is a bit tricky. Here's what I
did to make it work:

1. Install the regular Git package.
2. Install the PuTTY tools, including =pageant= and =plink=.
3. Manage your SSH keys using =pageant=
   1. Ideally, load your git-related keys on Windows startup.

After all of that I only needed the following config:

#+BEGIN_SRC emacs-lisp 
  (cond
   ((string-equal system-type "windows-nt")
    (progn
      (setenv "SSH_ASKPASS" "git-gui--askpass")
      (setenv "GIT_SSH" "C:/Program Files/PuTTY/plink.exe"))))
#+END_SRC
** Keymaps
#+BEGIN_SRC emacs-lisp 
  (progn
    (define-prefix-command 'tp/magit-key-map)
    (define-key tp/magit-key-map (kbd "s") 'magit-status)
    (define-key tp/magit-key-map (kbd "b") 'magit-branch-popup)
    (define-key tp/magit-key-map (kbd "c") 'magit-checkout)
    (define-key tp/magit-key-map (kbd "d") 'magit-diff-popup)
    )

 (global-set-key (kbd "\C-cm") tp/magit-key-map)
#+END_SRC

* Completion
** ido-ubiquitous
 
This is the package that auto-completes file names when you press =C-x C-f=.
 
#+BEGIN_SRC emacs-lisp
  (ido-mode 1)
  (ido-everywhere 1)
#+END_SRC

** smex
 
This package is a lot like ido-ubiquitous but it autocompletes values
when you press =M-x=:
 
#+BEGIN_SRC emacs-lisp
  (use-package smex
    :ensure t
    :config
    (smex-initialize)
    ;; :bind (("M-x" . smex)
    ;;        ("M-X" . smex-major-mode-commands)
    ;;        ("C-c C-c M-x" . 'execute-extended-command))
    )
#+END_SRC

Since I started using =helm= I don't think Smex does anything any more,
but I'm afraid to delete it at this point :-)

** Helm
   Use =helm= for =M-x= function searching:

#+BEGIN_SRC emacs-lisp
  (use-package helm
    :ensure t
    :bind (("M-x" . helm-M-x)
           ("C-x b" . helm-mini)))
#+END_SRC

* Timestamp Stuff
 
#+BEGIN_SRC emacs-lisp
  (defvar current-date-time-format "%a %b %d %H:%M:%S %Z %Y"
    "Format of date to insert with `insert-current-date-time' func
  See help of `format-time-string' for possible replacements")

  (defvar current-date-format-for-org "** %m/%d/%Y"
    "Format of date to insert with `insert-current-date' func for org files.
  See help of `format-time-string' for possible replacements")

  (defvar current-date-format-for-links "%m-%d-%Y"
    "This format works better for HTML links than the org format.")

  (defvar current-date-format "%m/%d/%Y"
    "Format of date to insert with `insert-current-date' func.
  Note the weekly scope of the command's precision.")

  (defvar current-time-format-for-org "*** %H:%M"
    "Format of date to insert with `insert-current-time' func for org files.
  Note the weekly scope of the command's precision.")

  (defvar current-time-format "%H:%M:%S"
    "Format of date to insert with `insert-current-time' func.
  Note the weekly scope of the command's precision.")

  (defvar current-time-format-no-delim "%H%M%S"
    "Format of date with no delimiters.")

  (defun insert-current-date-for-org ()
    "insert the current date as a heading into an org file.
  Uses `current-date-time-format' for the formatting the date/time."
    (interactive)
    (insert (format-time-string current-date-format-for-org (current-time)))
    (insert "\n")
    )

  (defun insert-current-date-for-links ()
    "Insert the current date in a way that works in HTML
    links."
    (interactive)
    (insert (format-time-string current-date-format-for-links (current-time)))
    )

  (defun get-current-date-for-links ()
    "Retrieves the current date in a way that works in HTML
    links."
    (interactive)
    (format-time-string current-date-format-for-links (current-time))
    )

  (defun insert-current-date ()
    "insert the current date into current buffer.
  Uses `current-date-time-format' for the formatting the date/time."
    (interactive)
    (insert (format-time-string current-date-format (current-time)))
    )

  (defun get-current-date ()
    "Returns the current date. Uses `current-date-time-format` for the formatting of the date/time"
    (interactive)
    (format-time-string current-date-format (current-time)))

  (defun insert-current-time-for-org ()
    "insert the current time as a heading into an org file."
    (interactive)
    (insert (format-time-string current-time-format-for-org (current-time)))
    (insert "\n")
    )

  (defun insert-new-day-headings ()
    "insert the 'new day' heading into an org file"
    (interactive)
    (insert-current-date-for-org)
    (insert "\n")
    (insert-current-time-for-org)
    (insert "\n")
    )

  (defun insert-current-date-time ()
    "insert the current date and time into current buffer.
  Uses `current-date-time-format' for the formatting the date/time."
    (interactive)
    (insert "==========\n")
					  ;       (insert (let () (comment-start)))
    (insert (format-time-string current-date-time-format (current-time)))
    (insert "\n")
    )

  (defun insert-current-time ()
    "insert the current time (1-week scope) into the current buffer."
    (interactive)
    (insert (format-time-string current-time-format (current-time)))
    )

  (defun get-current-time ()
    "Returns the current time (1-week scope).."
    (interactive)
    (format-time-string current-time-format (current-time)))

  (defun get-current-time-no-delim ()
    "Returns the current time with no delimiters."
    (interactive)
    (format-time-string current-time-format-no-delim (current-time)))

  (global-set-key "\C-c\C-d" 'insert-current-date-time)
  (global-set-key "\C-c\C-t" 'insert-current-time)
#+END_SRC

* Vim Compat
 
Here's some of the keystrokes from Vim that I still like to use.
 
This emulates Vim's "gg top" mnemonic:
 
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x gg") 'beginning-of-buffer)
  (global-set-key (kbd "C-x G")  'end-of-buffer)
#+END_SRC

* Dev
** Misc
*** Rainbow Delimiters

 #+BEGIN_SRC emacs-lisp
   (use-package rainbow-delimiters
     :ensure t
     :hook (prog-mode . rainbow-delimiters-mode))
 #+END_SRC

*** Linting

Flycheck relies on external programs to analyze your code. Here's what
you need to install for your favorite programming languages:

- Python
  - pylint
- Bash
  - shellcheck

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :hook (after-init . global-flycheck-mode))
#+END_SRC
*** Projectile
    [[https://www.projectile.mx/en/latest/usage/][Projectile]] is a fantastic package that makes it easier to work
    within a project using Emacs.

    I'm not a huge fan of it's built-in prefix though so let's fix
    that:

#+BEGIN_SRC emacs-lisp 
  (use-package projectile
    :ensure t
    :init
    (setq projectile-keymap-prefix (kbd "C-c p"))
    :config
    (projectile-mode +1))

  (use-package helm-projectile
    :ensure t
    :config
    (setq projectile-completion-system 'helm)
    (helm-projectile-on))
#+END_SRC

*** Indent
    This turns off tabs and replaces them with 4 spaces for most major
    modes:

 #+BEGIN_SRC emacs-lisp
   (setq-default c-basic-offset 4)
   (setq-default indent-tabs-mode nil)
 #+END_SRC

** Powershell
 
 #+BEGIN_SRC emacs-lisp
   (use-package powershell
     :ensure t
     :config
     (autoload 'powershell "powershell" "Run powershell as a shell within emacs." t) 
     )
 #+END_SRC
 
 #+RESULTS:
** Robot Mode
*** Bootstrap
    Unfortunately, you have to install =robot-mode= manually.
 #+BEGIN_SRC emacs-lisp
   (load "robot-mode")
   (add-to-list 'auto-mode-alist
                '("\\.txt\\'" . robot-mode)
                '("\\.robot\\'" . robot-mode))
 #+END_SRC
*** Hiding =^M= Characters In Robot Files
 #+BEGIN_SRC emacs-lisp
   (add-hook 'robot-mode-hook 'tp/remove-dos-eol)
 #+END_SRC
** Lisp
*** Paredit

Let's just turn it on for everything :smile: 

  #+BEGIN_SRC emacs-lisp
    (use-package paredit
      :ensure t
      :hook ((emacs-lisp-mode . enable-paredit-mode)
             (eval-expression-minibuffer-setup . enable-paredit-mode)
             (ielm-mode . enable-paredit-mode)
             (lisp-mode . enable-paredit-mode)
             (lisp-interaction-mode . enable-paredit-mode)
             (scheme-mode . enable-paredit-mode)))
  #+END_SRC
** Autoit
   Yet another package that we can't install from melpa.
#+BEGIN_SRC emacs-lisp
  (cond
   ((string-equal system-type "windows-nt")
    (progn
      (require 'autoit-mode)
      (add-to-list 'auto-mode-alist '("\\.au3\\'" . autoit-mode)))))
#+END_SRC
   
** Web
*** Running a web server
**** Overview
    [[https://elpa.gnu.org/packages/web-server.html][web-server]] is a great module that can interpret elisp or just
    serve up static files (which is how I use it). For me it provides
    a really easy way viewing HTML files in a browser in a "real" way.
**** Bootstrap
#+BEGIN_SRC emacs-lisp
  (use-package web-server
    :ensure t)
#+END_SRC
**** Convenience Functions
     This function starts a server on port 9003 that serves up static
     content that's located in the PWD (which is also your DOCROOT). 
#+BEGIN_SRC emacs-lisp
  (defun tp/start-server-in-pwd ()
    (interactive)
    (lexical-let ((docroot default-directory))
      (ws-start
       (lambda (request)
	 (with-slots (process headers) request
	   (let ((path (substring (cdr (assoc :GET headers)) 1)))
	     (if (ws-in-directory-p docroot path)
		 (if (file-directory-p path)
		     (ws-send-directory-list process
					     (expand-file-name path docroot) "^[^\.]")
		   (ws-send-file process (expand-file-name path docroot)))
	       (ws-send-404 process)))))
       9003))
    (message "Serving up files on port 9003."))
#+END_SRC
*** HTML
web-mode is awesome!

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode)))
#+END_SRC

** Python
*** Virtualenv
#+BEGIN_SRC emacs-lisp
  (use-package virtualenvwrapper
    :ensure t
    :config
    (venv-initialize-interactive-shells)
    (venv-initialize-eshell))
#+END_SRC

*** Auto-completion
#+BEGIN_SRC emacs-lisp
  (use-package jedi
    :ensure t
    :hook (python-mode . jedi:setup)
    :config
    (setq jedi:complete-on-dot t))
#+END_SRC
*** Editing Pip Requirements Files
    #+BEGIN_SRC emacs-lisp
      (use-package pip-requirements
        :ensure t)
    #+END_SRC
** Docker
   Let's add support for Dockerfiles!
   #+BEGIN_SRC emacs-lisp
     (use-package dockerfile-mode
       :ensure t
       :init
       (add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-mode)))
   #+END_SRC
** Stack Overflow
*** sx
    This a Stack Exchange browser for Emacs. As of today (3/20/2019) the version in MELPA
    stable has a pretty major bug in it so I'm using HEAD from Github:

    #+BEGIN_SRC emacs-lisp
      (use-package sx-load
        :load-path "customizations/packages/sx.el")
    #+END_SRC
* Text Search
** Ack

   The =ack= Emacs plugin looked sweet but I couldn't get it to work
   on Windows :-( Luckily the Silver Searcher worked!

** Ag (The Silver Searcher) And Helm Swoop

    Here's the basics:

#+BEGIN_SRC emacs-lisp
  (use-package ag
    :ensure t)
  (use-package helm-swoop
    :ensure t)
#+END_SRC

    I thought it would be nice to access the =ag-*= functions using a
    =Ctrl-c f= prefix, and the code below does exactly that (thanks to
    [[http://ergoemacs.org/emacs/emacs_keybinding_power_of_keys_sequence.html][Xah Lee]] once again).

    I also added a few =helm-swoop= shortcuts since that's also an
    excellent tool for searching files.

#+BEGIN_SRC emacs-lisp 
  (progn
    (define-prefix-command 'tp/ag-key-map)
    ; I'm having trouble searching within a project in a really fast way. Oh well.
    ;(define-key tp/ag-key-map (kbd "p") 'projectile-ag)
    ; Find in the current buffer.
    (define-key tp/ag-key-map (kbd "b") 'helm-swoop)
    ; Find using all open buffers
    (define-key tp/ag-key-map (kbd "o") 'helm-multi-swoop)
    ; Search all of your org buffers
    (define-key tp/ag-key-map (kbd "r") 'helm-org-rifle)
    ; And if you didn't trust any of these, try plain-old ag :-)
    (define-key tp/ag-key-map (kbd "a") 'ag)
    )

  (global-set-key (kbd "\C-cf") tp/ag-key-map)
#+END_SRC
** Wgrep
   Why not? It looks so *cool*.
#+BEGIN_SRC emacs-lisp
  (use-package wgrep
    :ensure t)
#+END_SRC
* Registers
** Org
#+BEGIN_SRC emacs-lisp 
  (set-register ?w (cons 'file (concat org-directory "/WorkLogs.org")))
  (set-register ?i (cons 'file (concat org-directory "/index.org")))
  (set-register ?m (cons 'file (concat org-directory "/MeetingMinutes.org")))
  (set-register ?v (cons 'file (concat org-directory "/Personal_Reviews.org")))
#+END_SRC
** OS-Specific
#+BEGIN_SRC emacs-lisp 
  (cond
   ((string-equal system-type "windows-nt")
    (progn
      (set-register ?p (cons 'file "c:/tools/cmder/config/user-profile.ps1"))
      (set-register ?h (cons 'file "~/Documents/Dev/AHK/hotstrings.ahk"))
      (set-register ?g (cons 'file "c:/users/tom.purl/.gitconfig"))
      (set-register ?r (cons 'file "c:/users/tom.purl/git/braindump/index.org"))))
   ((string-equal system-type "gnu/linux")
    (progn
      (set-register ?g (cons 'file "~/.gitconfig"))
      (set-register ?r (cons 'file "~/braindump/index.org"))))
   )
#+END_SRC
** Misc
#+BEGIN_SRC emacs-lisp 
  (set-register ?e (cons 'file "~/.emacs.d/emacs-init.org"))
#+END_SRC
* Log Editing / Viewing
** TODO Make mode load automatically *Log*.txt files
** TODO Make mode change file to RO 
  #+BEGIN_SRC emacs-lisp
    (use-package logview
      :ensure t
      )
  #+END_SRC
* Sunrise Commander
  Sunrise commander is a clone of midnight commander, also known as an orthodox file
  manager.

  Unfortunately, this package isn't available in MELPA, so you need to install it manually.

  #+BEGIN_SRC emacs-lisp
    (use-package sunrise-commander)
    (use-package sunrise-x-checkpoints
      :requires sunrise-commander)
    (global-set-key "\C-x\C-f" 'sunrise-cd)
  #+END_SRC

* Web Browsing
  Make =eww= create a new buffer if executed from a non-=eww= buffer. This allows you to
  easily create more than one =eww= buffer. Also, I copied this from
  https://emacs.stackexchange.com/a/24477/8228, which was copied from Xah's erogemacs tips
  (like a lot of stuff in this file).

  #+BEGIN_SRC emacs-lisp
    ;; Auto-rename new eww buffers
    (defun xah-rename-eww-hook ()
      "Rename eww browser's buffer so sites open in new page."
      (rename-buffer "eww" t))
    (add-hook 'eww-mode-hook #'xah-rename-eww-hook)
  #+END_SRC
* Scratch Buffer
** Saving And Restoring The Buffer
   Also stole from EOS:
   #+BEGIN_SRC emacs-lisp
     (defun eos/core/save-persistent-scratch ()
       "Write the contents of *scratch* to the file name
     `persistent-scratch-file-name'."
       (with-current-buffer (get-buffer-create "*scratch*")
         (write-region (point-min) (point-max) "~/.emacs.d/persistent-scratch")))

     (defun eos/core/load-persistent-scratch ()
       "Load the contents of `persistent-scratch-file-name' into the
       scratch buffer, clearing its contents first."
       (interactive)
       (if (file-exists-p "~/.emacs.d/persistent-scratch")
           (with-current-buffer (get-buffer "*scratch*")
             (delete-region (point-min) (point-max))
             (insert-file-contents "~/.emacs.d/persistent-scratch"))))

     (add-hook 'after-init-hook 'eos/core/load-persistent-scratch)
     (add-hook 'kill-emacs-hook 'eos/core/save-persistent-scratch)
   #+END_SRC

* Syncing
  I like to sync some of my files using Syncthing. The problem is when I do the following:

  1. Edit a file on my laptop and save and sync without killing the buffer.
  2. Edit the same file on my phone using Orgzly and sync.
  3. Sync everything on my laptop and visit the same buffer in Emacs.

  At this point I would be looking at the version of the file from step 1 on my laptop. To
  view the step 2 updates I would need to manually revert the buffer, and chances are I
  wouldn't know which buffers to revert.

  I therefore am turning on =global-auto-revert-mode= to see if that helps.

  #+BEGIN_SRC emacs-lisp
    (global-auto-revert-mode 1)
  #+END_SRC
* Markdown
  First, let's install the mode:

  #+BEGIN_SRC emacs-lisp
    (use-package markdown-mode
      :ensure t)
  #+END_SRC
* Window Management
  I just love this, it was stupid simple to write and I think I use it a least 10 times a
  day. It "moves" the current window into a new frame. 

  What does that mean? Let's say you split your current window (which is called a *frame*
  in Emacs) into 2 using =Ctrl-3= or something like that and then realize that you would
  /really/ like to focus on the buffer in that "split" (which is called a *window* in
  Emacs). Wouldn't it be great if you could just move it to a new frame?

  #+BEGIN_SRC emacs-lisp 
    (defun tp/move-window-to-new-frame ()
      "Take the content of the current window and move it to its own
       frame"
      (interactive)
      (make-frame)
      (delete-window))
  #+END_SRC

* Misc?
** Timers
   Chronos seems to do this really well, but unfortunately it isn't available (as of 2/4/19) in
   Melpa Stable. So you'll first want to download it and then do this:
   #+BEGIN_SRC emacs-lisp
     (require 'chronos)
   #+END_SRC
*** Notifications
    This is definitely a work in progress :-)
#+BEGIN_SRC emacs-lisp
  (cond
   ((string-equal system-type "windows-nt")
    (progn
      (setq chronos-shell-notify-program "c:/users/tom.purl/AppData/Roaming/Documents/td/apps/snarl 5.0/tools/heysnarl"
            chronos-shell-notify-parameters '("notify?text=Important!&priority=1")
            chronos-expiry-functions '(chronos-buffer-notify
                                       chronos-shell-notify)))))
#+END_SRC

** Jumping Between Buffers
   =ace-window= works well for this.

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :ensure t)
  (global-set-key (kbd "C-]") 'ace-window)
#+END_SRC

** Sound
   For god's sake, please don't beep.
   #+BEGIN_SRC emacs-lisp
     (setq ring-bell-function (lambda ()))
   #+END_SRC
